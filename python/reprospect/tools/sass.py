import dataclasses
import logging
import pathlib
import re
import typing

import typeguard

@dataclasses.dataclass(frozen = True)
class ControlCode:
    """
    `SASS` control code decoding.

    `SASS` instructions use 128-bit encoding:
        * 64-bit instruction word
        * 64-bit word including control code

    The control code manages instruction dependencies, scheduling, and resource usage.

    The control code is a section of 21 bits with the following structure:

    +------------------+---------------------------------------------+
    | number of bits   | meaning                                     |
    +==================+=============================================+
    | 4                | stall count (0-15 cycles)                   |
    +------------------+---------------------------------------------+
    | 1                | yield flag                                  |
    +------------------+---------------------------------------------+
    | 3                | write barrier                               |
    +------------------+---------------------------------------------+
    | 3                | read barrier                                |
    +------------------+---------------------------------------------+
    | 6                | wait barrier mask (one bit per barrier 0-5) |
    +------------------+---------------------------------------------+
    | 4                | reuse flags mask (for operands A, B, C, D)  |
    +------------------+---------------------------------------------+

    Barriers
    ========

    Coordinate dependencies between instructions executing on different functional units.
        * Write barrier is set when the instruction completes and produces a result.
          It marks that the register is ready. Later instructions reading that register must wait.
        * Read barrier indicates that the instruction needs a register with the result from a previous instruction
          to remain unchanged. Later instructions writing on that register must wait.
        * The wait barrier mask is a bit mask with the barriers that the instruction must wait for
          (*e.g.* write and read barriers set by preceding instructions).

    A write or read barrier value with the three bits set to 1, i.e., an integer value of 7, means that no such barrier is set.

    Note that barriers are related to [scoreboarding](https://en.wikipedia.org/wiki/Scoreboarding).

    The reader can refer to the following references for further description of barriers and scoreboard dependencies:
        * :cite:`jia-2018-dissecting-nvidia-volta-gpu` (section 2.1)
        * :cite:`huerta-2025-analyzing-modern-nvidia-gpu` (figure 2).

    Stall count
    ===========

    Explicitly insert delay cycles to account for latency.

    It can be set within the 0-15 cycles range.

    Reuse flags
    ===========

    Operand forwarding optimization - reuse data from previous instruction.
    There are 4 reuse flags (`A`, `B`, `C` and `D`).

    If a subsequent instruction uses the same register in the same operand slot,
    for instance operand slot `B`, the compiler may set `reuse_B` to avoid register traffic.

    Yield flag
    ==========

    Hint to scheduler to yield to other warps. It is mainly used for long-latency operations and
    allows better multi-warp interleaving, thus improving throughput.

    Notes
    =====

    * There are 6 barriers (6 scoreboard barriers for dependency tracking).
    * Each warp has its own set of barriers.
    * The GPU hardware automatically enforces barrier dependencies.
    * The control code is generated by the `Cuda` `ptxas` tool.

    References:
        * :cite:`maxas-wiki-control-codes`
    """
    stall_count: int
    yield_flag : bool
    read : int
    write: int
    wait : list[bool]
    reuse: dict[str, bool]

    @staticmethod
    @typeguard.typechecked
    def decode(*, code : str) -> 'ControlCode':
        """
        Decode 64-bit word including a control code.
        """
        # The 41 first bits encode something else.
        control = int(code, 16) >> 41

        # 4 bits stall count.
        stall_count = control & 0xF

        # 1 bit yield flag.
        yield_flag = bool((control >> 4) & 0x1)

        # 3 bits write.
        write_barrier = (control >> 5) & 0x7

        # 3 bits read.
        read_barrier = (control >> 8) & 0x7

        # 6 bits wait barrier mask.
        wait_mask = (control >> 11) & 0x3F
        wait_barriers = [bool((wait_mask >> i) & 1) for i in range(6)]

        reuse_flags = {
            'A': bool((control >> 17) & 1),
            'B': bool((control >> 18) & 1),
            'C': bool((control >> 19) & 1),
            'D': bool((control >> 20) & 1)
        }

        return ControlCode(
            stall_count = stall_count,
            yield_flag = yield_flag,
            read = read_barrier,
            write = write_barrier,
            wait = wait_barriers,
            reuse = reuse_flags,
        )

@dataclasses.dataclass(frozen = True)
class Instruction:
    """
    Represents a single `SASS` instruction with its components.
    """
    offset : int
    instruction : str
    hex : str
    control : ControlCode

class Decoder:
    """
    `NVIDIA` `SASS` instruction decoder.

    Simple decoder that parses `SASS` assembly and extracts key instruction information.
    """
    # Instruction is like:
    #   STG R1, R2
    INSTRUCTION = r'[A-Z0-9a-z,\. _\-!@\[\]]+'

    # HEX is like:
    #   0x00000a0000017a02
    HEX = r'[a-f0-9x]+'

    # Typical SASS line:
    #   /*0070*/ MOV R5, 0x4 ; /* 0x0000000400057802 */
    MATCHER = rf'\/\*({HEX})\*\/\s+({INSTRUCTION})\s*;\s+\/\* ({HEX}) \*\/'

    @typeguard.typechecked
    def __init__(self, source : typing.Optional[pathlib.Path] = None, code : typing.Optional[str] = None, skip_until_headerflags : bool = True) -> None:
        """
        Initialize the decoder with the `SASS` contained in `source` or `code`.
        """
        self.source = source
        self.code   = code
        self.instructions: list[Instruction] = []
        self._parse(skip_until_headerflags = skip_until_headerflags)

    @typeguard.typechecked
    def _parse(self, skip_until_headerflags : bool) -> None:
        """
        Parse `SASS` lines.
        """
        if self.source:
            self.code = self.source.read_text()

        lines = self.code.splitlines()

        iline = 0

        headerflags = False

        while iline < len(lines):
            line = lines[iline].strip()

            # The line containing '..........' means the end of the SASS code.
            if skip_until_headerflags:
                if '..........' in line:
                    break

            # Skip empty lines.
            if not line:
                iline += 1
                continue

            # Skip lines until '.headerflags' is met.
            if skip_until_headerflags:
                if not headerflags:
                    headerflags = '.headerflags' in line
                    iline += 1
                    continue

            # For a few architecture/compiler combinations, additional fields appear.
            # For instance:
            #   &wr=0x0          ?trans1;
            #   &req={1}         ?WAIT5_END_GROUP
            line = re.sub(pattern = r'&wr=[0-5x]+', repl = '', string = line)
            line = re.sub(pattern = r'&rd=[0-5x]+', repl = '', string = line)
            line = re.sub(pattern = r'\?trans[0-9]+', repl = '', string = line)
            line = re.sub(pattern = r'&req={[0-9]+}', repl = '', string = line)
            line = re.sub(pattern = r'\?WAIT[0-9]+_END_GROUP', repl = '', string = line)

            match = re.match(self.MATCHER, line)

            if not match:
                logging.error(f'The line:\n\t{line}\ndid not match {self.MATCHER}.')
                raise RuntimeError(line)

            # Extract instruction components.
            offset      = match.group(1).strip()
            instruction = match.group(2).strip()
            hex         = match.group(3).strip()

            # Check if next line contains the second hex word.
            if iline + 1 < len(lines):
                if (match := re.match(rf'\/\* ({self.HEX}) \*\/', lines[iline + 1].strip())):
                    control = ControlCode.decode(code = match.group(1))
                    iline += 1

            # Create instruction.
            instruction = Instruction(
                offset = int(offset, base = 16),
                instruction = instruction,
                hex = hex,
                control = control,
            )

            self.instructions.append(instruction)
            iline += 1
